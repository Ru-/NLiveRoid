/*
 * util.h
 *
 *  Created on: 2013/11/17
 *      Author: Owner
 */


#ifndef STRUCTS_H_
#include "structs.h"
#define STRUCTS_H_
#endif


#include <stdio.h>
#include <stddef.h>
#include <sys/time.h>


//呼び出し側で使用する関数
int video_get_buffer(AVCodecContext *s, AVFrame *pic);
int audio_get_buffer(AVCodecContext *s, AVFrame *pic);
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size);
int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int jobnr, int threadnr), void *arg, int *ret, int count);
enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt);
int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);



//----------------------------



void av_free(void *ptr);
void av_freep(void *arg);
void *av_malloc(size_t size);
void *av_mallocz(size_t size);
void *av_realloc(void *ptr, size_t size);

AVFrame *avcodec_alloc_frame();


inline int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f);
inline void ff_thread_finish_setup(AVCodecContext *avctx);
inline void free_frame_buffer(MpegEncContext *s, Picture *pic);
inline void free_progress(AVFrame *f);
inline void free_picture(MpegEncContext *s, Picture *pic);


int av_frame_copy_props(AVFrame *dst, const AVFrame *src);

int64_t av_gcd(int64_t a, int64_t b);


int avcodec_default_get_buffer(AVCodecContext *avctx, AVFrame *frame);
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt);



//for extern const
#define PIX_FMT_BE        1 ///< Pixel format is big-endian.
#define PIX_FMT_PAL       2 ///< Pixel format has a palette in data[1], values are indexes in this palette.
#define PIX_FMT_BITSTREAM 4 ///< All values of a component are bit-wise packed end to end.
#define PIX_FMT_HWACCEL   8 ///< Pixel format is an HW accelerated format.
#define PIX_FMT_PLANAR   16 ///< At least one pixel component is not in the first data plane
#define PIX_FMT_RGB      32 ///< The pixel format contains RGB-like data (as opposed to YUV/grayscale)
/**
 * The pixel format is "pseudo-paletted". This means that FFmpeg treats it as
 * paletted internally, but the palette is generated by the decoder and is not
 * stored in the file.
 */
#define PIX_FMT_PSEUDOPAL 64

#define PIX_FMT_ALPHA   128 ///< The pixel format has an alpha channel


const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB];
inline int image_get_linesize(int width, int plane,int max_step, int max_step_comp,const AVPixFmtDescriptor *desc);



/*
 * Codec supports frame-level multithreading.
 */
#define CODEC_CAP_FRAME_THREADS    0x1000
//#define CODEC_FLAG_TRUNCATED       0x00010000 // Input bitstream might be truncated at a random
//#define CODEC_FLAG_LOW_DELAY      0x00080000 ///< Force low delay.
//#define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
#define FF_THREAD_FRAME   1 ///< Decode more than one frame at once
/**
 *  Codec supports slice-based (or partition-based) multithreading.
 */
#define CODEC_CAP_SLICE_THREADS    0x2000
#define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
/* H264 slice threading seems to be buggy with more than 16 threads,
 * limit the number of threads to 16 for automatic detection */
#define MAX_AUTO_THREADS 16

extern const uint16_t ff_h263_format[8][2];

extern const uint8_t ff_mvtab[33][2];

extern const uint16_t ff_mpeg1_default_intra_matrix[256];
extern const uint8_t ff_zigzag_direct[64];
extern const uint8_t ff_mpeg1_dc_scale_table[128];
extern RLTable ff_h263_rl_inter;
extern RLTable ff_rl_intra_aic;

extern const uint16_t ff_inv_aanscales[64];
extern const uint8_t ff_alternate_vertical_scan[64];

inline const int av_clip_c(int a, int amin, int amax);

inline double av_q2d(AVRational a);
inline double qp2bits(RateControlEntry *rce, double qp);
inline double bits2qp(RateControlEntry *rce, double bits);
double get_qscale(MpegEncContext *s, RateControlEntry *rce,double rate_factor, int frame_num);

int ff_dct_quantize_c(MpegEncContext *s,int16_t *block, int n,int qscale, int *overflow);
void av_image_copy_plane(uint8_t       *dst, int dst_linesize,const uint8_t *src, int src_linesize,int bytewidth, int height);

extern uint32_t ff_squareTbl[512];

inline const uint8_t av_clip_uint8_c(int a);


double av_expr_eval(AVExpr *e, const double *const_values, void *opaque);

int ff_vbv_update(MpegEncContext *s, int frame_size);


double get_fps(AVCodecContext *avctx);
int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd);


#define AV_COPYU(n, d, s) AV_WN##n(d, AV_RN##n(s));
#   define AV_COPY64U(d, s) AV_COPYU(64, d, s)

#ifndef AV_COPY128U
#   define AV_COPY128U(d, s)                                    \
    do {                                                        \
        AV_COPY64U(d, s);                                       \
        AV_COPY64U((char *)(d) + 8, (const char *)(s) + 8);     \
    } while(0)
#endif
inline void copy_block17(uint8_t *dst, const uint8_t *src, int dstStride, int srcStride, int h);


int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples,enum AVSampleFormat sample_fmt, int align);


int64_t av_gettime(void);
int av_codec_is_decoder(const AVCodec *codec);

#define INT_MAX 2147483647
#define INT_MIN (__INT_MAX__-1)


int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq,
                         enum AVRounding rnd);

void avcodec_get_frame_defaults(AVFrame *frame);


void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4],
                                const AVPixFmtDescriptor *pixdesc);

void ff_init_buffer_info(AVCodecContext *s, AVFrame *frame);

void av_init_packet(AVPacket *pkt);

int av_reduce(int *dst_num, int *dst_den,
              int64_t num, int64_t den, int64_t max);

int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame);

int ff_frame_thread_encoder_init(AVCodecContext *avctx, AVDictionary *options);

int ff_alloc_packet2(AVCodecContext *avctx, AVPacket *avpkt, int size);

void ff_set_cmp(DSPContext* c, me_cmp_func *cmp, int type);

void av_destruct_packet(AVPacket *pkt);

void av_free_packet(AVPacket *pkt);
